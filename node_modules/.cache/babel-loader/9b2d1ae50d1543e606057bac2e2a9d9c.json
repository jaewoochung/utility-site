{"ast":null,"code":"'use strict';\n\nvar url = require('url'),\n    equal = require('fast-deep-equal'),\n    util = require('./util'),\n    SchemaObject = require('./schema_obj'),\n    traverse = require('json-schema-traverse');\n\nmodule.exports = resolve;\nresolve.normalizeId = normalizeId;\nresolve.fullPath = getFullPath;\nresolve.url = resolveUrl;\nresolve.ids = resolveIds;\nresolve.inlineRef = inlineRef;\nresolve.schema = resolveSchema;\n/**\n * [resolve and compile the references ($ref)]\n * @this   Ajv\n * @param  {Function} compile reference to schema compilation funciton (localCompile)\n * @param  {Object} root object with information about the root schema for the current schema\n * @param  {String} ref reference to resolve\n * @return {Object|Function} schema object (if the schema can be inlined) or validation function\n */\n\nfunction resolve(compile, root, ref) {\n  /* jshint validthis: true */\n  var refVal = this._refs[ref];\n\n  if (typeof refVal == 'string') {\n    if (this._refs[refVal]) refVal = this._refs[refVal];else return resolve.call(this, compile, root, refVal);\n  }\n\n  refVal = refVal || this._schemas[ref];\n\n  if (refVal instanceof SchemaObject) {\n    return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);\n  }\n\n  var res = resolveSchema.call(this, root, ref);\n  var schema, v, baseId;\n\n  if (res) {\n    schema = res.schema;\n    root = res.root;\n    baseId = res.baseId;\n  }\n\n  if (schema instanceof SchemaObject) {\n    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);\n  } else if (schema !== undefined) {\n    v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, undefined, baseId);\n  }\n\n  return v;\n}\n/**\n * Resolve schema, its root and baseId\n * @this Ajv\n * @param  {Object} root root object with properties schema, refVal, refs\n * @param  {String} ref  reference to resolve\n * @return {Object} object with properties schema, root, baseId\n */\n\n\nfunction resolveSchema(root, ref) {\n  /* jshint validthis: true */\n  var p = url.parse(ref, false, true),\n      refPath = _getFullPath(p),\n      baseId = getFullPath(this._getId(root.schema));\n\n  if (refPath !== baseId) {\n    var id = normalizeId(refPath);\n    var refVal = this._refs[id];\n\n    if (typeof refVal == 'string') {\n      return resolveRecursive.call(this, root, refVal, p);\n    } else if (refVal instanceof SchemaObject) {\n      if (!refVal.validate) this._compile(refVal);\n      root = refVal;\n    } else {\n      refVal = this._schemas[id];\n\n      if (refVal instanceof SchemaObject) {\n        if (!refVal.validate) this._compile(refVal);\n        if (id == normalizeId(ref)) return {\n          schema: refVal,\n          root: root,\n          baseId: baseId\n        };\n        root = refVal;\n      } else {\n        return;\n      }\n    }\n\n    if (!root.schema) return;\n    baseId = getFullPath(this._getId(root.schema));\n  }\n\n  return getJsonPointer.call(this, p, baseId, root.schema, root);\n}\n/* @this Ajv */\n\n\nfunction resolveRecursive(root, ref, parsedRef) {\n  /* jshint validthis: true */\n  var res = resolveSchema.call(this, root, ref);\n\n  if (res) {\n    var schema = res.schema;\n    var baseId = res.baseId;\n    root = res.root;\n\n    var id = this._getId(schema);\n\n    if (id) baseId = resolveUrl(baseId, id);\n    return getJsonPointer.call(this, parsedRef, baseId, schema, root);\n  }\n}\n\nvar PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);\n/* @this Ajv */\n\nfunction getJsonPointer(parsedRef, baseId, schema, root) {\n  /* jshint validthis: true */\n  parsedRef.hash = parsedRef.hash || '';\n  if (parsedRef.hash.slice(0, 2) != '#/') return;\n  var parts = parsedRef.hash.split('/');\n\n  for (var i = 1; i < parts.length; i++) {\n    var part = parts[i];\n\n    if (part) {\n      part = util.unescapeFragment(part);\n      schema = schema[part];\n      if (schema === undefined) break;\n      var id;\n\n      if (!PREVENT_SCOPE_CHANGE[part]) {\n        id = this._getId(schema);\n        if (id) baseId = resolveUrl(baseId, id);\n\n        if (schema.$ref) {\n          var $ref = resolveUrl(baseId, schema.$ref);\n          var res = resolveSchema.call(this, root, $ref);\n\n          if (res) {\n            schema = res.schema;\n            root = res.root;\n            baseId = res.baseId;\n          }\n        }\n      }\n    }\n  }\n\n  if (schema !== undefined && schema !== root.schema) return {\n    schema: schema,\n    root: root,\n    baseId: baseId\n  };\n}\n\nvar SIMPLE_INLINED = util.toHash(['type', 'format', 'pattern', 'maxLength', 'minLength', 'maxProperties', 'minProperties', 'maxItems', 'minItems', 'maximum', 'minimum', 'uniqueItems', 'multipleOf', 'required', 'enum']);\n\nfunction inlineRef(schema, limit) {\n  if (limit === false) return false;\n  if (limit === undefined || limit === true) return checkNoRef(schema);else if (limit) return countKeys(schema) <= limit;\n}\n\nfunction checkNoRef(schema) {\n  var item;\n\n  if (Array.isArray(schema)) {\n    for (var i = 0; i < schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object' && !checkNoRef(item)) return false;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return false;\n      item = schema[key];\n      if (typeof item == 'object' && !checkNoRef(item)) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction countKeys(schema) {\n  var count = 0,\n      item;\n\n  if (Array.isArray(schema)) {\n    for (var i = 0; i < schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object') count += countKeys(item);\n      if (count == Infinity) return Infinity;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return Infinity;\n\n      if (SIMPLE_INLINED[key]) {\n        count++;\n      } else {\n        item = schema[key];\n        if (typeof item == 'object') count += countKeys(item) + 1;\n        if (count == Infinity) return Infinity;\n      }\n    }\n  }\n\n  return count;\n}\n\nfunction getFullPath(id, normalize) {\n  if (normalize !== false) id = normalizeId(id);\n  var p = url.parse(id, false, true);\n  return _getFullPath(p);\n}\n\nfunction _getFullPath(p) {\n  var protocolSeparator = p.protocol || p.href.slice(0, 2) == '//' ? '//' : '';\n  return (p.protocol || '') + protocolSeparator + (p.host || '') + (p.path || '') + '#';\n}\n\nvar TRAILING_SLASH_HASH = /#\\/?$/;\n\nfunction normalizeId(id) {\n  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';\n}\n\nfunction resolveUrl(baseId, id) {\n  id = normalizeId(id);\n  return url.resolve(baseId, id);\n}\n/* @this Ajv */\n\n\nfunction resolveIds(schema) {\n  var schemaId = normalizeId(this._getId(schema));\n  var baseIds = {\n    '': schemaId\n  };\n  var fullPaths = {\n    '': getFullPath(schemaId, false)\n  };\n  var localRefs = {};\n  var self = this;\n  traverse(schema, {\n    allKeys: true\n  }, function (sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n    if (jsonPtr === '') return;\n\n    var id = self._getId(sch);\n\n    var baseId = baseIds[parentJsonPtr];\n    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;\n    if (keyIndex !== undefined) fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));\n\n    if (typeof id == 'string') {\n      id = baseId = normalizeId(baseId ? url.resolve(baseId, id) : id);\n      var refVal = self._refs[id];\n      if (typeof refVal == 'string') refVal = self._refs[refVal];\n\n      if (refVal && refVal.schema) {\n        if (!equal(sch, refVal.schema)) throw new Error('id \"' + id + '\" resolves to more than one schema');\n      } else if (id != normalizeId(fullPath)) {\n        if (id[0] == '#') {\n          if (localRefs[id] && !equal(sch, localRefs[id])) throw new Error('id \"' + id + '\" resolves to more than one schema');\n          localRefs[id] = sch;\n        } else {\n          self._refs[id] = fullPath;\n        }\n      }\n    }\n\n    baseIds[jsonPtr] = baseId;\n    fullPaths[jsonPtr] = fullPath;\n  });\n  return localRefs;\n}","map":{"version":3,"sources":["/Users/jaewoochung/Documents/github_repositories/dashboard/node_modules/har-validator/node_modules/ajv/lib/compile/resolve.js"],"names":["url","require","equal","util","SchemaObject","traverse","module","exports","resolve","normalizeId","fullPath","getFullPath","resolveUrl","ids","resolveIds","inlineRef","schema","resolveSchema","compile","root","ref","refVal","_refs","call","_schemas","_opts","inlineRefs","validate","_compile","res","v","baseId","undefined","p","parse","refPath","_getFullPath","_getId","id","resolveRecursive","getJsonPointer","parsedRef","PREVENT_SCOPE_CHANGE","toHash","hash","slice","parts","split","i","length","part","unescapeFragment","$ref","SIMPLE_INLINED","limit","checkNoRef","countKeys","item","Array","isArray","key","count","Infinity","normalize","protocolSeparator","protocol","href","host","path","TRAILING_SLASH_HASH","replace","schemaId","baseIds","fullPaths","localRefs","self","allKeys","sch","jsonPtr","rootSchema","parentJsonPtr","parentKeyword","parentSchema","keyIndex","escapeFragment","Error"],"mappings":"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","sourcesContent":["'use strict';\n\nvar url = require('url')\n  , equal = require('fast-deep-equal')\n  , util = require('./util')\n  , SchemaObject = require('./schema_obj')\n  , traverse = require('json-schema-traverse');\n\nmodule.exports = resolve;\n\nresolve.normalizeId = normalizeId;\nresolve.fullPath = getFullPath;\nresolve.url = resolveUrl;\nresolve.ids = resolveIds;\nresolve.inlineRef = inlineRef;\nresolve.schema = resolveSchema;\n\n/**\n * [resolve and compile the references ($ref)]\n * @this   Ajv\n * @param  {Function} compile reference to schema compilation funciton (localCompile)\n * @param  {Object} root object with information about the root schema for the current schema\n * @param  {String} ref reference to resolve\n * @return {Object|Function} schema object (if the schema can be inlined) or validation function\n */\nfunction resolve(compile, root, ref) {\n  /* jshint validthis: true */\n  var refVal = this._refs[ref];\n  if (typeof refVal == 'string') {\n    if (this._refs[refVal]) refVal = this._refs[refVal];\n    else return resolve.call(this, compile, root, refVal);\n  }\n\n  refVal = refVal || this._schemas[ref];\n  if (refVal instanceof SchemaObject) {\n    return inlineRef(refVal.schema, this._opts.inlineRefs)\n            ? refVal.schema\n            : refVal.validate || this._compile(refVal);\n  }\n\n  var res = resolveSchema.call(this, root, ref);\n  var schema, v, baseId;\n  if (res) {\n    schema = res.schema;\n    root = res.root;\n    baseId = res.baseId;\n  }\n\n  if (schema instanceof SchemaObject) {\n    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);\n  } else if (schema !== undefined) {\n    v = inlineRef(schema, this._opts.inlineRefs)\n        ? schema\n        : compile.call(this, schema, root, undefined, baseId);\n  }\n\n  return v;\n}\n\n\n/**\n * Resolve schema, its root and baseId\n * @this Ajv\n * @param  {Object} root root object with properties schema, refVal, refs\n * @param  {String} ref  reference to resolve\n * @return {Object} object with properties schema, root, baseId\n */\nfunction resolveSchema(root, ref) {\n  /* jshint validthis: true */\n  var p = url.parse(ref, false, true)\n    , refPath = _getFullPath(p)\n    , baseId = getFullPath(this._getId(root.schema));\n  if (refPath !== baseId) {\n    var id = normalizeId(refPath);\n    var refVal = this._refs[id];\n    if (typeof refVal == 'string') {\n      return resolveRecursive.call(this, root, refVal, p);\n    } else if (refVal instanceof SchemaObject) {\n      if (!refVal.validate) this._compile(refVal);\n      root = refVal;\n    } else {\n      refVal = this._schemas[id];\n      if (refVal instanceof SchemaObject) {\n        if (!refVal.validate) this._compile(refVal);\n        if (id == normalizeId(ref))\n          return { schema: refVal, root: root, baseId: baseId };\n        root = refVal;\n      } else {\n        return;\n      }\n    }\n    if (!root.schema) return;\n    baseId = getFullPath(this._getId(root.schema));\n  }\n  return getJsonPointer.call(this, p, baseId, root.schema, root);\n}\n\n\n/* @this Ajv */\nfunction resolveRecursive(root, ref, parsedRef) {\n  /* jshint validthis: true */\n  var res = resolveSchema.call(this, root, ref);\n  if (res) {\n    var schema = res.schema;\n    var baseId = res.baseId;\n    root = res.root;\n    var id = this._getId(schema);\n    if (id) baseId = resolveUrl(baseId, id);\n    return getJsonPointer.call(this, parsedRef, baseId, schema, root);\n  }\n}\n\n\nvar PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);\n/* @this Ajv */\nfunction getJsonPointer(parsedRef, baseId, schema, root) {\n  /* jshint validthis: true */\n  parsedRef.hash = parsedRef.hash || '';\n  if (parsedRef.hash.slice(0,2) != '#/') return;\n  var parts = parsedRef.hash.split('/');\n\n  for (var i = 1; i < parts.length; i++) {\n    var part = parts[i];\n    if (part) {\n      part = util.unescapeFragment(part);\n      schema = schema[part];\n      if (schema === undefined) break;\n      var id;\n      if (!PREVENT_SCOPE_CHANGE[part]) {\n        id = this._getId(schema);\n        if (id) baseId = resolveUrl(baseId, id);\n        if (schema.$ref) {\n          var $ref = resolveUrl(baseId, schema.$ref);\n          var res = resolveSchema.call(this, root, $ref);\n          if (res) {\n            schema = res.schema;\n            root = res.root;\n            baseId = res.baseId;\n          }\n        }\n      }\n    }\n  }\n  if (schema !== undefined && schema !== root.schema)\n    return { schema: schema, root: root, baseId: baseId };\n}\n\n\nvar SIMPLE_INLINED = util.toHash([\n  'type', 'format', 'pattern',\n  'maxLength', 'minLength',\n  'maxProperties', 'minProperties',\n  'maxItems', 'minItems',\n  'maximum', 'minimum',\n  'uniqueItems', 'multipleOf',\n  'required', 'enum'\n]);\nfunction inlineRef(schema, limit) {\n  if (limit === false) return false;\n  if (limit === undefined || limit === true) return checkNoRef(schema);\n  else if (limit) return countKeys(schema) <= limit;\n}\n\n\nfunction checkNoRef(schema) {\n  var item;\n  if (Array.isArray(schema)) {\n    for (var i=0; i<schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object' && !checkNoRef(item)) return false;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return false;\n      item = schema[key];\n      if (typeof item == 'object' && !checkNoRef(item)) return false;\n    }\n  }\n  return true;\n}\n\n\nfunction countKeys(schema) {\n  var count = 0, item;\n  if (Array.isArray(schema)) {\n    for (var i=0; i<schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object') count += countKeys(item);\n      if (count == Infinity) return Infinity;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return Infinity;\n      if (SIMPLE_INLINED[key]) {\n        count++;\n      } else {\n        item = schema[key];\n        if (typeof item == 'object') count += countKeys(item) + 1;\n        if (count == Infinity) return Infinity;\n      }\n    }\n  }\n  return count;\n}\n\n\nfunction getFullPath(id, normalize) {\n  if (normalize !== false) id = normalizeId(id);\n  var p = url.parse(id, false, true);\n  return _getFullPath(p);\n}\n\n\nfunction _getFullPath(p) {\n  var protocolSeparator = p.protocol || p.href.slice(0,2) == '//' ? '//' : '';\n  return (p.protocol||'') + protocolSeparator + (p.host||'') + (p.path||'')  + '#';\n}\n\n\nvar TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';\n}\n\n\nfunction resolveUrl(baseId, id) {\n  id = normalizeId(id);\n  return url.resolve(baseId, id);\n}\n\n\n/* @this Ajv */\nfunction resolveIds(schema) {\n  var schemaId = normalizeId(this._getId(schema));\n  var baseIds = {'': schemaId};\n  var fullPaths = {'': getFullPath(schemaId, false)};\n  var localRefs = {};\n  var self = this;\n\n  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n    if (jsonPtr === '') return;\n    var id = self._getId(sch);\n    var baseId = baseIds[parentJsonPtr];\n    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;\n    if (keyIndex !== undefined)\n      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));\n\n    if (typeof id == 'string') {\n      id = baseId = normalizeId(baseId ? url.resolve(baseId, id) : id);\n\n      var refVal = self._refs[id];\n      if (typeof refVal == 'string') refVal = self._refs[refVal];\n      if (refVal && refVal.schema) {\n        if (!equal(sch, refVal.schema))\n          throw new Error('id \"' + id + '\" resolves to more than one schema');\n      } else if (id != normalizeId(fullPath)) {\n        if (id[0] == '#') {\n          if (localRefs[id] && !equal(sch, localRefs[id]))\n            throw new Error('id \"' + id + '\" resolves to more than one schema');\n          localRefs[id] = sch;\n        } else {\n          self._refs[id] = fullPath;\n        }\n      }\n    }\n    baseIds[jsonPtr] = baseId;\n    fullPaths[jsonPtr] = fullPath;\n  });\n\n  return localRefs;\n}\n"]},"metadata":{},"sourceType":"script"}