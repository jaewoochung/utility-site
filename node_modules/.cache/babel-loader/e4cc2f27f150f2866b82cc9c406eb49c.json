{"ast":null,"code":"'use strict';\n\nvar IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;\n\nvar customRuleCode = require('./dotjs/custom');\n\nmodule.exports = {\n  add: addKeyword,\n  get: getKeyword,\n  remove: removeKeyword\n};\n/**\n * Define custom keyword\n * @this  Ajv\n * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).\n * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.\n * @return {Ajv} this for method chaining\n */\n\nfunction addKeyword(keyword, definition) {\n  /* jshint validthis: true */\n\n  /* eslint no-shadow: 0 */\n  var RULES = this.RULES;\n  if (RULES.keywords[keyword]) throw new Error('Keyword ' + keyword + ' is already defined');\n  if (!IDENTIFIER.test(keyword)) throw new Error('Keyword ' + keyword + ' is not a valid identifier');\n\n  if (definition) {\n    if (definition.macro && definition.valid !== undefined) throw new Error('\"valid\" option cannot be used with macro keywords');\n    var dataType = definition.type;\n\n    if (Array.isArray(dataType)) {\n      var i,\n          len = dataType.length;\n\n      for (i = 0; i < len; i++) checkDataType(dataType[i]);\n\n      for (i = 0; i < len; i++) _addRule(keyword, dataType[i], definition);\n    } else {\n      if (dataType) checkDataType(dataType);\n\n      _addRule(keyword, dataType, definition);\n    }\n\n    var $data = definition.$data === true && this._opts.$data;\n    if ($data && !definition.validate) throw new Error('$data support: \"validate\" function is not defined');\n    var metaSchema = definition.metaSchema;\n\n    if (metaSchema) {\n      if ($data) {\n        metaSchema = {\n          anyOf: [metaSchema, {\n            '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#'\n          }]\n        };\n      }\n\n      definition.validateSchema = this.compile(metaSchema, true);\n    }\n  }\n\n  RULES.keywords[keyword] = RULES.all[keyword] = true;\n\n  function _addRule(keyword, dataType, definition) {\n    var ruleGroup;\n\n    for (var i = 0; i < RULES.length; i++) {\n      var rg = RULES[i];\n\n      if (rg.type == dataType) {\n        ruleGroup = rg;\n        break;\n      }\n    }\n\n    if (!ruleGroup) {\n      ruleGroup = {\n        type: dataType,\n        rules: []\n      };\n      RULES.push(ruleGroup);\n    }\n\n    var rule = {\n      keyword: keyword,\n      definition: definition,\n      custom: true,\n      code: customRuleCode,\n      implements: definition.implements\n    };\n    ruleGroup.rules.push(rule);\n    RULES.custom[keyword] = rule;\n  }\n\n  function checkDataType(dataType) {\n    if (!RULES.types[dataType]) throw new Error('Unknown type ' + dataType);\n  }\n\n  return this;\n}\n/**\n * Get keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.\n */\n\n\nfunction getKeyword(keyword) {\n  /* jshint validthis: true */\n  var rule = this.RULES.custom[keyword];\n  return rule ? rule.definition : this.RULES.keywords[keyword] || false;\n}\n/**\n * Remove keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Ajv} this for method chaining\n */\n\n\nfunction removeKeyword(keyword) {\n  /* jshint validthis: true */\n  var RULES = this.RULES;\n  delete RULES.keywords[keyword];\n  delete RULES.all[keyword];\n  delete RULES.custom[keyword];\n\n  for (var i = 0; i < RULES.length; i++) {\n    var rules = RULES[i].rules;\n\n    for (var j = 0; j < rules.length; j++) {\n      if (rules[j].keyword == keyword) {\n        rules.splice(j, 1);\n        break;\n      }\n    }\n  }\n\n  return this;\n}","map":{"version":3,"sources":["/Users/jaewoochung/Documents/github_repositories/dashboard/node_modules/har-validator/node_modules/ajv/lib/keyword.js"],"names":["IDENTIFIER","customRuleCode","require","module","exports","add","addKeyword","get","getKeyword","remove","removeKeyword","keyword","definition","RULES","keywords","Error","test","macro","valid","undefined","dataType","type","Array","isArray","i","len","length","checkDataType","_addRule","$data","_opts","validate","metaSchema","anyOf","validateSchema","compile","all","ruleGroup","rg","rules","push","rule","custom","code","implements","types","j","splice"],"mappings":"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","sourcesContent":["'use strict';\n\nvar IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;\nvar customRuleCode = require('./dotjs/custom');\n\nmodule.exports = {\n  add: addKeyword,\n  get: getKeyword,\n  remove: removeKeyword\n};\n\n/**\n * Define custom keyword\n * @this  Ajv\n * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).\n * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.\n * @return {Ajv} this for method chaining\n */\nfunction addKeyword(keyword, definition) {\n  /* jshint validthis: true */\n  /* eslint no-shadow: 0 */\n  var RULES = this.RULES;\n\n  if (RULES.keywords[keyword])\n    throw new Error('Keyword ' + keyword + ' is already defined');\n\n  if (!IDENTIFIER.test(keyword))\n    throw new Error('Keyword ' + keyword + ' is not a valid identifier');\n\n  if (definition) {\n    if (definition.macro && definition.valid !== undefined)\n      throw new Error('\"valid\" option cannot be used with macro keywords');\n\n    var dataType = definition.type;\n    if (Array.isArray(dataType)) {\n      var i, len = dataType.length;\n      for (i=0; i<len; i++) checkDataType(dataType[i]);\n      for (i=0; i<len; i++) _addRule(keyword, dataType[i], definition);\n    } else {\n      if (dataType) checkDataType(dataType);\n      _addRule(keyword, dataType, definition);\n    }\n\n    var $data = definition.$data === true && this._opts.$data;\n    if ($data && !definition.validate)\n      throw new Error('$data support: \"validate\" function is not defined');\n\n    var metaSchema = definition.metaSchema;\n    if (metaSchema) {\n      if ($data) {\n        metaSchema = {\n          anyOf: [\n            metaSchema,\n            { '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#' }\n          ]\n        };\n      }\n      definition.validateSchema = this.compile(metaSchema, true);\n    }\n  }\n\n  RULES.keywords[keyword] = RULES.all[keyword] = true;\n\n\n  function _addRule(keyword, dataType, definition) {\n    var ruleGroup;\n    for (var i=0; i<RULES.length; i++) {\n      var rg = RULES[i];\n      if (rg.type == dataType) {\n        ruleGroup = rg;\n        break;\n      }\n    }\n\n    if (!ruleGroup) {\n      ruleGroup = { type: dataType, rules: [] };\n      RULES.push(ruleGroup);\n    }\n\n    var rule = {\n      keyword: keyword,\n      definition: definition,\n      custom: true,\n      code: customRuleCode,\n      implements: definition.implements\n    };\n    ruleGroup.rules.push(rule);\n    RULES.custom[keyword] = rule;\n  }\n\n\n  function checkDataType(dataType) {\n    if (!RULES.types[dataType]) throw new Error('Unknown type ' + dataType);\n  }\n\n  return this;\n}\n\n\n/**\n * Get keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.\n */\nfunction getKeyword(keyword) {\n  /* jshint validthis: true */\n  var rule = this.RULES.custom[keyword];\n  return rule ? rule.definition : this.RULES.keywords[keyword] || false;\n}\n\n\n/**\n * Remove keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Ajv} this for method chaining\n */\nfunction removeKeyword(keyword) {\n  /* jshint validthis: true */\n  var RULES = this.RULES;\n  delete RULES.keywords[keyword];\n  delete RULES.all[keyword];\n  delete RULES.custom[keyword];\n  for (var i=0; i<RULES.length; i++) {\n    var rules = RULES[i].rules;\n    for (var j=0; j<rules.length; j++) {\n      if (rules[j].keyword == keyword) {\n        rules.splice(j, 1);\n        break;\n      }\n    }\n  }\n  return this;\n}\n"]},"metadata":{},"sourceType":"script"}